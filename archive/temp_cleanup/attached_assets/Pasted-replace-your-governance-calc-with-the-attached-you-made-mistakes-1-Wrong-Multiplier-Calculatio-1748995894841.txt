replace your governance calc with the attached you made mistakes. 

‚ùå 1. Wrong Multiplier Calculation for Locked Deposits
Takisoul's wallet (7pPJt2xo...)

Expected: ~8.7M

Got: 18.9M (!! over 2x)

GJdRQcsy's wallet

Expected: ~144.7K

Got: 275.8K

üî¥ Root cause:
The formula inside calculateCorrectMultiplier() overestimates the lockedRatio for constant/vesting lockups.
It treats the entire remaining lockup as if it gets full bonus, without accounting for VSR‚Äôs time-weighted vesting curve.

‚ùå 2. Double-counting deposits from offset and lockup patterns
In parseAllDeposits(), they:

Scan the same offsets for both multiLockupOffsets and directOffsets

Try to deduplicate, but only by fuzzy amount comparison (Math.abs(d.amount - amount) < 1), which is fragile and fails on repeated patterns

üî¥ Fix needed: Use a strict offset blacklist to avoid reading the same bytes twice.

‚ùå 3. No canonical VSR multiplier curve
They hardcoded a saturation logic like this:

js
Copy
Edit
return (baseline + maxExtra * ratio) / 1e9;
But this:

Ignores deposit duration vs. max multiplier scaling curve

Doesn‚Äôt apply the time-weighted multiplier for kind 2 and 3 (vesting and constant)

üî¥ Fix needed: Use your already-prepared, spec-compliant calculateMultiplier() module with proper curve handling.

‚ö†Ô∏è 4. Phantom delegation deposits are excluded correctly (‚úÖ), but logic is fragile

if (rounded === 1000 || rounded === 11000) continue;
‚úÖ Good that they‚Äôre skipping them.
‚ö†Ô∏è But this should move outside parseAllDeposits and become a filter applied before any multiplier logic.

Here‚Äôs the corrected flow we'll enforce:

üß† 1. Scanner
Skip phantom 1,000 and 11,000 deposits before parsing

Use a set of canonical offsets (184, 264, 344, 424) for multi-lockup

Extract:

amount from offset

kind from offset + 24 (or similar)

startTs and endTs from neighboring offsets

üì¶ 2. Multiplier Module
Input: { kind, startTs, endTs }

Apply saturation-based scaling using:

cliff: simple time-remaining ratio

vesting and constant: time-weighted average multiplier curve

Return precise multiplier (e.g. 1.87x)

üíæ 3. Deduplication
Based on offsets, not just amount

Never count the same byte range twice

üßπ 4. Clean JSON result
For each citizen:

lockedPower

unlockedPower

totalPower

List of deposits with source, offset, and multiplier